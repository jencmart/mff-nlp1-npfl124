\chapter{Symbolic Analysis}
Static analysis of a program inspects the code but does not try to execute it. Another approach is dynamic analysis when the program is analyzed by executing the program using a set of inputs.
In the MANTA Flow only static analysis is used. Symbolic analysis is a type of static analysis. The inspection can be done directly by analyzing the source code, but a more practical approach is to analyze machine code or an intermediate representation. In our case, we use intermediate representation based on a parse tree.

\section{Analysis Sensitivity}
Analysis of program code with respect to dataflow is an undecidable problem~\cite{turing}, thus only approximation is possible. The approximation should be over-approximation. In other words, the dataflow should contain more and not less than the true dataflow would be. The analysis will be flow sensitive. This means, that we can distinguish the order of the expressions and take it into account during analysis. Symbolic analysis can be either context-sensitive or insensitive. Sensitivity to the context means, that we can take into account when a method is called with particular parameters from a specific point in the program. On the other hand, context insensitive analysis does not take this into account. Symbolic analysis is in some parts context insensitive and context-sensitive in other parts.

\section{Intermediate Representation}
Commonly, analyses usually utilize some kind of intermediate representation. In our case, we will utilize the output from the ANTLR parser. The result is a parse tree, which we transform into a representation that is suitable for us. The resulting parse tree preserves the order of expressions and determines their type. Working with this representation is suitable for the analysis because we can easily traverse all the expressions.

\section{Algorithm Outline}
During the symbolic analysis, we basically iterate over methods and analyze them. The analysis starts in a given entry-point method. During the analysis, we use a queue (so called worklist) of methods to be processed. The worklist is filled with methods reachable from the entry-point. Each method is analyzed with respect to its invocation context. The invocation context is given by the point, where is method called, by the specific parameters. Due to the dynamic nature of Python, it is often hard to determine what is the method is called. In such a case we analyze all methods that are matched by the heuristic. Part of the project focuses on providing the set of possible method targets. Because a single method has usually multiple invocation contexts, we analyze the method for each of them. During the method analysis, we update the flow summary. An important part of the algorithm is that when the summary of a method changes, we need to add all callers and callees of that method with the current invocation context because their
summaries can be affected by the change of a summary of the currently analyzed method. When we have no other methods to analyze (i.e. the worklist queue is empty), the analysis ends.

\section{Analysis of Special methods}
Even though a lot of Python libraries are distributed with the source code available, there are still cases, when we do not have the source code, thus we are unable to access the expressions in the method. For instance, the popular Python package NumPy is largely implemented in the C language, and we are given only the declaration of the methods. Besides specific libraries, all of Python's built-in methods are not accessible. We can't analyze the expression in these methods, so we can only approximate by terms of explicit summary modification based on the knowledge of a specific method. Because the supported frameworks and methods can be extended almost indefinitely, we provide the easy plugin architecture, where we can tackle a specific library with an additional plugin. Whenever we encounter such a method, instead of analyzing the method directly, we let the plugin change the summary based on the known semantic of the method. Last but not least, we can encounter a method, which is not handled by any plugin and for which we don't have the source code available. In such a case, we assume that the flow is not changed by the method.

\section{Alias Analysis}
Access or modification of an object can be done using a reference variable. For correct symbolic analysis, we need to know that both variables reference the same. The reference is a kind of alias and we want to know these aliases so that we can compute the flow for all aliased variables. Due to the dynamic nature of the Python language, this is not always possible, but we compute the aliases when it is.